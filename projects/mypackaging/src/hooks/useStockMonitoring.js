import { useState, useEffect, useCallback, useRef } from 'react';
import { 
  collection, 
  query, 
  onSnapshot, 
  orderBy,
  doc,
  updateDoc,
  Timestamp 
} from 'firebase/firestore';
import { db } from '../firebase';
import { logActivity } from '../lib/auditLog';

export const useStockMonitoring = () => {
  const [stockAlerts, setStockAlerts] = useState([]);
  const [products, setProducts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [settings, setSettings] = useState({
    globalReorderPoint: 10,
    criticalStockLevel: 5,
    enableAutoNotifications: true,
    checkInterval: 60000, // 1 minute
    alertCooldown: 300000 // 5 minutes between same alerts
  });

  // Cache for preventing duplicate alerts
  const alertCache = useRef(new Map());

  const logStockEvents = useCallback(async (alerts) => {
    try {
      for (const alert of alerts) {
        await logActivity(
          'stock_alert',
          'system',
          `Stock alert generated: ${alert.message}`,
          'alert',
          {
            productId: alert.productId,
            productName: alert.productName,
            alertType: alert.type,
            currentStock: alert.currentStock,
            reorderPoint: alert.reorderPoint,
            urgency: alert.urgency
          }
        );
      }
    } catch (error) {
      console.error('Error logging stock events:', error);
    }
  }, []);

  const analyzeStock = useCallback((productsData) => {
    if (!productsData.length) return;

    const alerts = [];
    const now = Date.now();

    productsData.forEach(product => {
      const stockBalance = product.stockBalance || 0;
      const reorderPoint = product.reorderPoint || settings.globalReorderPoint;
      const productName = product.name;
      const productId = product.id;

      // Check cooldown for this product
      const lastAlertTime = alertCache.current.get(productId) || 0;
      const cooldownExpired = (now - lastAlertTime) > settings.alertCooldown;

      // Critical stock alert (out of stock)
      if (stockBalance <= 0 && cooldownExpired) {
        alerts.push({
          id: `critical-${productId}`,
          productId,
          productName,
          type: 'critical',
          level: 'out-of-stock',
          currentStock: stockBalance,
          reorderPoint,
          message: `${productName} is completely out of stock`,
          urgency: 'immediate',
          suggestedAction: 'emergency_reorder',
          timestamp: new Date(),
          autoGenerated: true
        });
        alertCache.current.set(productId, now);
      }
      
      // Low stock warning
      else if (stockBalance <= settings.criticalStockLevel && stockBalance > 0 && cooldownExpired) {
        alerts.push({
          id: `critical-low-${productId}`,
          productId,
          productName,
          type: 'warning',
          level: 'critical-low',
          currentStock: stockBalance,
          reorderPoint,
          message: `${productName} is critically low (${stockBalance} units remaining)`,
          urgency: 'high',
          suggestedAction: 'immediate_reorder',
          timestamp: new Date(),
          autoGenerated: true
        });
        alertCache.current.set(productId, now);
      }
      
      // Standard reorder point alert
      else if (stockBalance <= reorderPoint && stockBalance > settings.criticalStockLevel && cooldownExpired) {
        alerts.push({
          id: `reorder-${productId}`,
          productId,
          productName,
          type: 'info',
          level: 'reorder-point',
          currentStock: stockBalance,
          reorderPoint,
          message: `${productName} has reached reorder point (${stockBalance} units remaining)`,
          urgency: 'medium',
          suggestedAction: 'schedule_reorder',
          timestamp: new Date(),
          autoGenerated: true
        });
        alertCache.current.set(productId, now);
      }
    });

    setStockAlerts(alerts.sort((a, b) => {
      // Sort by urgency: immediate -> high -> medium
      const urgencyOrder = { immediate: 0, high: 1, medium: 2 };
      return urgencyOrder[a.urgency] - urgencyOrder[b.urgency];
    }));

    // Log significant stock events
    if (alerts.length > 0) {
      logStockEvents(alerts);
    }
  }, [settings.globalReorderPoint, settings.criticalStockLevel, settings.alertCooldown, logStockEvents]);

  useEffect(() => {
    const subscribeToProducts = () => {
      try {
        const productsQuery = query(collection(db, 'products'), orderBy('name'));
        
        return onSnapshot(productsQuery, (snapshot) => {
          const productsData = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data()
          }));
          
          setProducts(productsData);
          analyzeStock(productsData);
          setLoading(false);
        });
      } catch (error) {
        console.error('Error subscribing to products:', error);
        setLoading(false);
        return () => {};
      }
    };

    const unsubscribe = subscribeToProducts();
    
    return () => {
      unsubscribe();
    };
  }, [analyzeStock]);

  // Separate effect for periodic checks
  useEffect(() => {
    if (!settings.enableAutoNotifications || !products.length) return;
    
    const interval = setInterval(() => {
      analyzeStock(products);
    }, settings.checkInterval);
    
    return () => clearInterval(interval);
  }, [settings.enableAutoNotifications, settings.checkInterval, products, analyzeStock]);

  const updateProductReorderPoint = async (productId, newReorderPoint) => {
    try {
      const productRef = doc(db, 'products', productId);
      await updateDoc(productRef, {
        reorderPoint: Number(newReorderPoint),
        lastUpdated: Timestamp.now()
      });

      await logActivity(
        'reorder_point_update',
        'user', // This will be enhanced with actual user context
        `Updated reorder point to ${newReorderPoint}`,
        'update',
        {
          productId,
          newReorderPoint: Number(newReorderPoint)
        }
      );

      return true;
    } catch (error) {
      console.error('Error updating reorder point:', error);
      throw error;
    }
  };

  const dismissAlert = (alertId) => {
    setStockAlerts(prev => prev.filter(alert => alert.id !== alertId));
  };

  const markAlertAsHandled = async (alert, action) => {
    try {
      await logActivity(
        'stock_alert_handled',
        'user',
        `Stock alert handled: ${action} for ${alert.productName}`,
        'action',
        {
          alertId: alert.id,
          productId: alert.productId,
          action,
          originalStock: alert.currentStock
        }
      );

      dismissAlert(alert.id);
    } catch (error) {
      console.error('Error marking alert as handled:', error);
    }
  };

  const getStockStatus = (product) => {
    const stockBalance = product.stockBalance || 0;
    const reorderPoint = product.reorderPoint || settings.globalReorderPoint;

    if (stockBalance <= 0) return 'out-of-stock';
    if (stockBalance <= settings.criticalStockLevel) return 'critical-low';
    if (stockBalance <= reorderPoint) return 'low-stock';
    return 'normal';
  };

  const getStockHealthMetrics = () => {
    if (!products.length) return null;

    const metrics = {
      totalProducts: products.length,
      outOfStock: 0,
      criticalLow: 0,
      lowStock: 0,
      normal: 0,
      averageStockLevel: 0,
      totalStockValue: 0,
      reorderSuggestions: []
    };

    let totalStock = 0;
    let totalValue = 0;

    products.forEach(product => {
      const status = getStockStatus(product);
      const stockBalance = product.stockBalance || 0;
      const unitPrice = product.unitPrice || 0;

      metrics[status.replace('-', '')]++;
      totalStock += stockBalance;
      totalValue += stockBalance * unitPrice;

      // Generate reorder suggestions
      if (status !== 'normal') {
        const suggestedQuantity = Math.max(
          (product.reorderPoint || settings.globalReorderPoint) * 2,
          50 // Minimum reorder quantity
        );
        
        metrics.reorderSuggestions.push({
          productId: product.id,
          productName: product.name,
          currentStock: stockBalance,
          suggestedQuantity,
          estimatedCost: suggestedQuantity * unitPrice,
          priority: status === 'out-of-stock' ? 'immediate' : 
                   status === 'critical-low' ? 'high' : 'medium'
        });
      }
    });

    metrics.averageStockLevel = totalStock / products.length;
    metrics.totalStockValue = totalValue;
    
    // Sort reorder suggestions by priority
    metrics.reorderSuggestions.sort((a, b) => {
      const priorityOrder = { immediate: 0, high: 1, medium: 2 };
      return priorityOrder[a.priority] - priorityOrder[b.priority];
    });

    return metrics;
  };

  const updateSettings = (newSettings) => {
    setSettings(prev => ({ ...prev, ...newSettings }));
    
    // Re-analyze stock with new settings
    analyzeStock(products);
  };

  return {
    stockAlerts,
    products,
    loading,
    settings,
    updateSettings,
    updateProductReorderPoint,
    dismissAlert,
    markAlertAsHandled,
    getStockStatus,
    getStockHealthMetrics: getStockHealthMetrics(),
    hasStockIssues: stockAlerts.length > 0,
    criticalAlerts: stockAlerts.filter(alert => alert.urgency === 'immediate').length,
    warningAlerts: stockAlerts.filter(alert => alert.urgency === 'high').length
  };
};